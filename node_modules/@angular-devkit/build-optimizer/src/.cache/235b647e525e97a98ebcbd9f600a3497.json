{"remainingRequest":"D:\\Documents\\VS Code Projects\\photo-sharing-app\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\Documents\\VS Code Projects\\photo-sharing-app\\node_modules\\@firebase\\firestore\\dist\\esm\\src\\core\\view.js","dependencies":[{"path":"D:\\Documents\\VS Code Projects\\photo-sharing-app\\node_modules\\@firebase\\firestore\\dist\\esm\\src\\core\\view.js","mtime":1519691373403},{"path":"D:\\Documents\\VS Code Projects\\photo-sharing-app\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1518892899207},{"path":"D:\\Documents\\VS Code Projects\\photo-sharing-app\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518892910875}],"contextDependencies":[],"result":["/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { documentKeySet } from '../model/collections';\r\nimport { Document } from '../model/document';\r\nimport { DocumentSet } from '../model/document_set';\r\nimport { CurrentStatusUpdate, ResetMapping, UpdateMapping } from '../remote/remote_event';\r\nimport { assert, fail } from '../util/assert';\r\nimport { OnlineState } from './types';\r\nimport { ChangeType, DocumentChangeSet, SyncState, ViewSnapshot } from './view_snapshot';\r\nvar AddedLimboDocument = /*@__PURE__*/ (function () {\r\n    function AddedLimboDocument(key) {\r\n        this.key = key;\r\n    }\r\n    return AddedLimboDocument;\r\n}());\r\nexport { AddedLimboDocument };\r\nvar RemovedLimboDocument = /*@__PURE__*/ (function () {\r\n    function RemovedLimboDocument(key) {\r\n        this.key = key;\r\n    }\r\n    return RemovedLimboDocument;\r\n}());\r\nexport { RemovedLimboDocument };\r\n/**\r\n * View is responsible for computing the final merged truth of what docs are in\r\n * a query. It gets notified of local and remote changes to docs, and applies\r\n * the query filters and limits to determine the most correct possible results.\r\n */\r\nvar View = /*@__PURE__*/ (function () {\r\n    function View(query, \r\n        /** Documents included in the remote target */\r\n        syncedDocuments) {\r\n        this.query = query;\r\n        this.syncedDocuments = syncedDocuments;\r\n        this.syncState = null;\r\n        /**\r\n         * A flag whether the view is current with the backend. A view is considered\r\n         * current after it has seen the current flag from the backend and did not\r\n         * lose consistency within the watch stream (e.g. because of an existence\r\n         * filter mismatch).\r\n         */\r\n        this.current = false;\r\n        /** Documents in the view but not in the remote target */\r\n        this.limboDocuments = documentKeySet();\r\n        /** Document Keys that have local changes */\r\n        this.mutatedKeys = documentKeySet();\r\n        this.documentSet = new DocumentSet(query.docComparator.bind(query));\r\n    }\r\n    /**\r\n     * Iterates over a set of doc changes, applies the query limit, and computes\r\n     * what the new results should be, what the changes were, and whether we may\r\n     * need to go back to the local cache for more results. Does not make any\r\n     * changes to the view.\r\n     * @param docChanges The doc changes to apply to this view.\r\n     * @param previousChanges If this is being called with a refill, then start\r\n     *        with this set of docs and changes instead of the current view.\r\n     * @return a new set of docs, changes, and refill flag.\r\n     */\r\n    View.prototype.computeDocChanges = function (docChanges, previousChanges) {\r\n        var _this = this;\r\n        var changeSet = previousChanges\r\n            ? previousChanges.changeSet\r\n            : new DocumentChangeSet();\r\n        var oldDocumentSet = previousChanges\r\n            ? previousChanges.documentSet\r\n            : this.documentSet;\r\n        var newMutatedKeys = previousChanges\r\n            ? previousChanges.mutatedKeys\r\n            : this.mutatedKeys;\r\n        var newDocumentSet = oldDocumentSet;\r\n        var needsRefill = false;\r\n        // Track the last doc in a (full) limit. This is necessary, because some\r\n        // update (a delete, or an update moving a doc past the old limit) might\r\n        // mean there is some other document in the local cache that either should\r\n        // come (1) between the old last limit doc and the new last document, in the\r\n        // case of updates, or (2) after the new last document, in the case of\r\n        // deletes. So we keep this doc at the old limit to compare the updates to.\r\n        //\r\n        // Note that this should never get used in a refill (when previousChanges is\r\n        // set), because there will only be adds -- no deletes or updates.\r\n        var lastDocInLimit = this.query.hasLimit() && oldDocumentSet.size === this.query.limit\r\n            ? oldDocumentSet.last()\r\n            : null;\r\n        docChanges.inorderTraversal(function (key, newMaybeDoc) {\r\n            var oldDoc = oldDocumentSet.get(key);\r\n            var newDoc = newMaybeDoc instanceof Document ? newMaybeDoc : null;\r\n            if (newDoc) {\r\n                assert(key.isEqual(newDoc.key), 'Mismatching keys found in document changes: ' +\r\n                    key +\r\n                    ' != ' +\r\n                    newDoc.key);\r\n                newDoc = _this.query.matches(newDoc) ? newDoc : null;\r\n            }\r\n            if (newDoc) {\r\n                newDocumentSet = newDocumentSet.add(newDoc);\r\n                if (newDoc.hasLocalMutations) {\r\n                    newMutatedKeys = newMutatedKeys.add(key);\r\n                }\r\n                else {\r\n                    newMutatedKeys = newMutatedKeys.delete(key);\r\n                }\r\n            }\r\n            else {\r\n                newDocumentSet = newDocumentSet.delete(key);\r\n                newMutatedKeys = newMutatedKeys.delete(key);\r\n            }\r\n            // Calculate change\r\n            if (oldDoc && newDoc) {\r\n                var docsEqual = oldDoc.data.isEqual(newDoc.data);\r\n                if (!docsEqual ||\r\n                    oldDoc.hasLocalMutations !== newDoc.hasLocalMutations) {\r\n                    // only report a change if document actually changed\r\n                    if (docsEqual) {\r\n                        changeSet.track({ type: ChangeType.Metadata, doc: newDoc });\r\n                    }\r\n                    else {\r\n                        changeSet.track({ type: ChangeType.Modified, doc: newDoc });\r\n                    }\r\n                    if (lastDocInLimit &&\r\n                        _this.query.docComparator(newDoc, lastDocInLimit) > 0) {\r\n                        // This doc moved from inside the limit to after the limit.\r\n                        // That means there may be some doc in the local cache that's\r\n                        // actually less than this one.\r\n                        needsRefill = true;\r\n                    }\r\n                }\r\n            }\r\n            else if (!oldDoc && newDoc) {\r\n                changeSet.track({ type: ChangeType.Added, doc: newDoc });\r\n            }\r\n            else if (oldDoc && !newDoc) {\r\n                changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\r\n                if (lastDocInLimit) {\r\n                    // A doc was removed from a full limit query. We'll need to\r\n                    // requery from the local cache to see if we know about some other\r\n                    // doc that should be in the results.\r\n                    needsRefill = true;\r\n                }\r\n            }\r\n        });\r\n        if (this.query.hasLimit()) {\r\n            // TODO(klimt): Make DocumentSet size be constant time.\r\n            while (newDocumentSet.size > this.query.limit) {\r\n                var oldDoc = newDocumentSet.last();\r\n                newDocumentSet = newDocumentSet.delete(oldDoc.key);\r\n                changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\r\n            }\r\n        }\r\n        assert(!needsRefill || !previousChanges, 'View was refilled using docs that themselves needed refilling.');\r\n        return {\r\n            documentSet: newDocumentSet,\r\n            changeSet: changeSet,\r\n            needsRefill: needsRefill,\r\n            mutatedKeys: newMutatedKeys\r\n        };\r\n    };\r\n    /**\r\n     * Updates the view with the given ViewDocumentChanges and updates limbo docs\r\n     * and sync state from the given (optional) target change.\r\n     * @param docChanges The set of changes to make to the view's docs.\r\n     * @param targetChange A target change to apply for computing limbo docs and\r\n     *        sync state.\r\n     * @return A new ViewChange with the given docs, changes, and sync state.\r\n     */\r\n    View.prototype.applyChanges = function (docChanges, targetChange) {\r\n        var _this = this;\r\n        assert(!docChanges.needsRefill, 'Cannot apply changes that need a refill');\r\n        var oldDocs = this.documentSet;\r\n        this.documentSet = docChanges.documentSet;\r\n        this.mutatedKeys = docChanges.mutatedKeys;\r\n        // Sort changes based on type and query comparator\r\n        var changes = docChanges.changeSet.getChanges();\r\n        changes.sort(function (c1, c2) {\r\n            return (compareChangeType(c1.type, c2.type) ||\r\n                _this.query.docComparator(c1.doc, c2.doc));\r\n        });\r\n        this.applyTargetChange(targetChange);\r\n        var limboChanges = this.updateLimboDocuments();\r\n        var synced = this.limboDocuments.size === 0 && this.current;\r\n        var newSyncState = synced ? SyncState.Synced : SyncState.Local;\r\n        var syncStateChanged = newSyncState !== this.syncState;\r\n        this.syncState = newSyncState;\r\n        if (changes.length === 0 && !syncStateChanged) {\r\n            // no changes\r\n            return { limboChanges: limboChanges };\r\n        }\r\n        else {\r\n            var snap = new ViewSnapshot(this.query, docChanges.documentSet, oldDocs, changes, newSyncState === SyncState.Local, !docChanges.mutatedKeys.isEmpty(), syncStateChanged);\r\n            return {\r\n                snapshot: snap,\r\n                limboChanges: limboChanges\r\n            };\r\n        }\r\n    };\r\n    /**\r\n     * Applies an OnlineState change to the view, potentially generating a\r\n     * ViewChange if the view's syncState changes as a result.\r\n     */\r\n    View.prototype.applyOnlineStateChange = function (onlineState) {\r\n        if (this.current && onlineState === OnlineState.Failed) {\r\n            // If we're offline, set `current` to false and then call applyChanges()\r\n            // to refresh our syncState and generate a ViewChange as appropriate. We\r\n            // are guaranteed to get a new TargetChange that sets `current` back to\r\n            // true once the client is back online.\r\n            this.current = false;\r\n            return this.applyChanges({\r\n                documentSet: this.documentSet,\r\n                changeSet: new DocumentChangeSet(),\r\n                mutatedKeys: this.mutatedKeys,\r\n                needsRefill: false\r\n            });\r\n        }\r\n        else {\r\n            // No effect, just return a no-op ViewChange.\r\n            return { limboChanges: [] };\r\n        }\r\n    };\r\n    /**\r\n     * Returns whether the doc for the given key should be in limbo.\r\n     */\r\n    View.prototype.shouldBeInLimbo = function (key) {\r\n        // If the remote end says it's part of this query, it's not in limbo.\r\n        if (this.syncedDocuments.has(key)) {\r\n            return false;\r\n        }\r\n        // The local store doesn't think it's a result, so it shouldn't be in limbo.\r\n        if (!this.documentSet.has(key)) {\r\n            return false;\r\n        }\r\n        // If there are local changes to the doc, they might explain why the server\r\n        // doesn't know that it's part of the query. So don't put it in limbo.\r\n        // TODO(klimt): Ideally, we would only consider changes that might actually\r\n        // affect this specific query.\r\n        if (this.documentSet.get(key).hasLocalMutations) {\r\n            return false;\r\n        }\r\n        // Everything else is in limbo.\r\n        return true;\r\n    };\r\n    /**\r\n     * Updates syncedDocuments, current, and limbo docs based on the given change.\r\n     * Returns the list of changes to which docs are in limbo.\r\n     */\r\n    View.prototype.applyTargetChange = function (targetChange) {\r\n        if (targetChange) {\r\n            var targetMapping = targetChange.mapping;\r\n            if (targetMapping instanceof ResetMapping) {\r\n                this.syncedDocuments = targetMapping.documents;\r\n            }\r\n            else if (targetMapping instanceof UpdateMapping) {\r\n                this.syncedDocuments = targetMapping.applyToKeySet(this.syncedDocuments);\r\n            }\r\n            switch (targetChange.currentStatusUpdate) {\r\n                case CurrentStatusUpdate.MarkCurrent:\r\n                    this.current = true;\r\n                    break;\r\n                case CurrentStatusUpdate.MarkNotCurrent:\r\n                    this.current = false;\r\n                    break;\r\n                case CurrentStatusUpdate.None:\r\n                    break;\r\n                default:\r\n                    fail('Unknown current status update: ' + targetChange.currentStatusUpdate);\r\n            }\r\n        }\r\n    };\r\n    View.prototype.updateLimboDocuments = function () {\r\n        var _this = this;\r\n        // We can only determine limbo documents when we're in-sync with the server.\r\n        if (!this.current) {\r\n            return [];\r\n        }\r\n        // TODO(klimt): Do this incrementally so that it's not quadratic when\r\n        // updating many documents.\r\n        var oldLimboDocuments = this.limboDocuments;\r\n        this.limboDocuments = documentKeySet();\r\n        this.documentSet.forEach(function (doc) {\r\n            if (_this.shouldBeInLimbo(doc.key)) {\r\n                _this.limboDocuments = _this.limboDocuments.add(doc.key);\r\n            }\r\n        });\r\n        // Diff the new limbo docs with the old limbo docs.\r\n        var changes = [];\r\n        oldLimboDocuments.forEach(function (key) {\r\n            if (!_this.limboDocuments.has(key)) {\r\n                changes.push(new RemovedLimboDocument(key));\r\n            }\r\n        });\r\n        this.limboDocuments.forEach(function (key) {\r\n            if (!oldLimboDocuments.has(key)) {\r\n                changes.push(new AddedLimboDocument(key));\r\n            }\r\n        });\r\n        return changes;\r\n    };\r\n    return View;\r\n}());\r\nexport { View };\r\nfunction compareChangeType(c1, c2) {\r\n    var order = function (change) {\r\n        switch (change) {\r\n            case ChangeType.Added:\r\n                return 1;\r\n            case ChangeType.Modified:\r\n                return 2;\r\n            case ChangeType.Metadata:\r\n                // A metadata change is converted to a modified change at the public\r\n                // api layer.  Since we sort by document key and then change type,\r\n                // metadata and modified changes must be sorted equivalently.\r\n                return 2;\r\n            case ChangeType.Removed:\r\n                return 0;\r\n            default:\r\n                return fail('Unknown ChangeType: ' + change);\r\n        }\r\n    };\r\n    return order(c1) - order(c2);\r\n}\r\n//# sourceMappingURL=view.js.map\r\n",null]}