{"remainingRequest":"D:\\Documents\\VS Code Projects\\photo-sharing-app\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\Documents\\VS Code Projects\\photo-sharing-app\\node_modules\\@firebase\\firestore\\dist\\esm\\src\\api\\credentials.js","dependencies":[{"path":"D:\\Documents\\VS Code Projects\\photo-sharing-app\\node_modules\\@firebase\\firestore\\dist\\esm\\src\\api\\credentials.js","mtime":1519691373096},{"path":"D:\\Documents\\VS Code Projects\\photo-sharing-app\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1518892899207},{"path":"D:\\Documents\\VS Code Projects\\photo-sharing-app\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518892910875}],"contextDependencies":[],"result":["/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { User } from '../auth/user';\r\nimport { assert, fail } from '../util/assert';\r\nimport { Code, FirestoreError } from '../util/error';\r\nvar OAuthToken = /*@__PURE__*/ (function () {\r\n    function OAuthToken(value, user) {\r\n        this.user = user;\r\n        this.type = 'OAuth';\r\n        this.authHeaders = { Authorization: \"Bearer \" + value };\r\n    }\r\n    return OAuthToken;\r\n}());\r\nexport { OAuthToken };\r\n/** A CredentialsProvider that always yields an empty token. */\r\nvar EmptyCredentialsProvider = /*@__PURE__*/ (function () {\r\n    function EmptyCredentialsProvider() {\r\n        /**\r\n         * Stores the User listener registered with setUserChangeListener()\r\n         * This isn't actually necessary since the UID never changes, but we use this\r\n         * to verify the listen contract is adhered to in tests.\r\n         */\r\n        this.userListener = null;\r\n    }\r\n    EmptyCredentialsProvider.prototype.getToken = function (forceRefresh) {\r\n        return Promise.resolve(null);\r\n    };\r\n    EmptyCredentialsProvider.prototype.setUserChangeListener = function (listener) {\r\n        assert(!this.userListener, 'Can only call setUserChangeListener() once.');\r\n        this.userListener = listener;\r\n        // Fire with initial user.\r\n        listener(User.UNAUTHENTICATED);\r\n    };\r\n    EmptyCredentialsProvider.prototype.removeUserChangeListener = function () {\r\n        assert(this.userListener !== null, 'removeUserChangeListener() when no listener registered');\r\n        this.userListener = null;\r\n    };\r\n    return EmptyCredentialsProvider;\r\n}());\r\nexport { EmptyCredentialsProvider };\r\nvar FirebaseCredentialsProvider = /*@__PURE__*/ (function () {\r\n    function FirebaseCredentialsProvider(app) {\r\n        var _this = this;\r\n        this.app = app;\r\n        /**\r\n         * The auth token listener registered with FirebaseApp, retained here so we\r\n         * can unregister it.\r\n         */\r\n        this.tokenListener = null;\r\n        /**\r\n         * Counter used to detect if the user changed while a getToken request was\r\n         * outstanding.\r\n         */\r\n        this.userCounter = 0;\r\n        /** The User listener registered with setUserChangeListener(). */\r\n        this.userListener = null;\r\n        // We listen for token changes but all we really care about is knowing when\r\n        // the uid may have changed.\r\n        this.tokenListener = function () {\r\n            var newUser = _this.getUser();\r\n            if (!_this.currentUser || !newUser.isEqual(_this.currentUser)) {\r\n                _this.currentUser = newUser;\r\n                _this.userCounter++;\r\n                if (_this.userListener) {\r\n                    _this.userListener(_this.currentUser);\r\n                }\r\n            }\r\n        };\r\n        this.userCounter = 0;\r\n        // Will fire at least once where we set this.currentUser\r\n        this.app.INTERNAL.addAuthTokenListener(this.tokenListener);\r\n    }\r\n    FirebaseCredentialsProvider.prototype.getToken = function (forceRefresh) {\r\n        var _this = this;\r\n        assert(this.tokenListener != null, 'getToken cannot be called after listener removed.');\r\n        // Take note of the current value of the userCounter so that this method can\r\n        // fail (with an ABORTED error) if there is a user change while the request\r\n        // is outstanding.\r\n        var initialUserCounter = this.userCounter;\r\n        return this.app.INTERNAL.getToken(forceRefresh).then(function (tokenData) {\r\n            // Cancel the request since the user changed while the request was\r\n            // outstanding so the response is likely for a previous user (which\r\n            // user, we can't be sure).\r\n            if (_this.userCounter !== initialUserCounter) {\r\n                throw new FirestoreError(Code.ABORTED, 'getToken aborted due to uid change.');\r\n            }\r\n            else {\r\n                if (tokenData) {\r\n                    assert(typeof tokenData.accessToken === 'string', 'Invalid tokenData returned from getToken():' + tokenData);\r\n                    return new OAuthToken(tokenData.accessToken, _this.currentUser);\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n        });\r\n    };\r\n    FirebaseCredentialsProvider.prototype.setUserChangeListener = function (listener) {\r\n        assert(!this.userListener, 'Can only call setUserChangeListener() once.');\r\n        this.userListener = listener;\r\n        // Fire the initial event, but only if we received the initial user\r\n        if (this.currentUser) {\r\n            listener(this.currentUser);\r\n        }\r\n    };\r\n    FirebaseCredentialsProvider.prototype.removeUserChangeListener = function () {\r\n        assert(this.tokenListener != null, 'removeUserChangeListener() called twice');\r\n        assert(this.userListener !== null, 'removeUserChangeListener() called when no listener registered');\r\n        this.app.INTERNAL.removeAuthTokenListener(this.tokenListener);\r\n        this.tokenListener = null;\r\n        this.userListener = null;\r\n    };\r\n    FirebaseCredentialsProvider.prototype.getUser = function () {\r\n        // TODO(mikelehen): Remove this check once we're shipping with firebase.js.\r\n        if (typeof this.app.INTERNAL.getUid !== 'function') {\r\n            fail('This version of the Firestore SDK requires at least version' +\r\n                ' 3.7.0 of firebase.js.');\r\n        }\r\n        var currentUid = this.app.INTERNAL.getUid();\r\n        assert(currentUid === null || typeof currentUid === 'string', 'Received invalid UID: ' + currentUid);\r\n        return new User(currentUid);\r\n    };\r\n    return FirebaseCredentialsProvider;\r\n}());\r\nexport { FirebaseCredentialsProvider };\r\n/*\r\n * FirstPartyToken provides a fresh token each time its value\r\n * is requested, because if the token is too old, requests will be rejected.\r\n * TODO(b/33147818) this implementation violates the current assumption that\r\n * tokens are immutable.  We need to either revisit this assumption or come\r\n * up with some way for FPA to use the listen/unlisten interface.\r\n */\r\nvar FirstPartyToken = /*@__PURE__*/ (function () {\r\n    function FirstPartyToken(gapi, sessionIndex) {\r\n        this.gapi = gapi;\r\n        this.sessionIndex = sessionIndex;\r\n        this.type = 'FirstParty';\r\n        this.user = User.FIRST_PARTY;\r\n        assert(this.gapi &&\r\n            this.gapi['auth'] &&\r\n            this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');\r\n    }\r\n    Object.defineProperty(FirstPartyToken.prototype, \"authHeaders\", {\r\n        get: function () {\r\n            return {\r\n                Authorization: this.gapi['auth']['getAuthHeaderValueForFirstParty']([]),\r\n                'X-Goog-AuthUser': this.sessionIndex\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return FirstPartyToken;\r\n}());\r\nexport { FirstPartyToken };\r\n/*\r\n * Provides user credentials required for the Firestore JavaScript SDK\r\n * to authenticate the user, using technique that is only available\r\n * to applications hosted by Google.\r\n */\r\nvar FirstPartyCredentialsProvider = /*@__PURE__*/ (function () {\r\n    function FirstPartyCredentialsProvider(gapi, sessionIndex) {\r\n        this.gapi = gapi;\r\n        this.sessionIndex = sessionIndex;\r\n        assert(this.gapi &&\r\n            this.gapi['auth'] &&\r\n            this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');\r\n    }\r\n    FirstPartyCredentialsProvider.prototype.getToken = function (forceRefresh) {\r\n        return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex));\r\n    };\r\n    // TODO(33108925): can someone switch users w/o a page refresh?\r\n    // TODO(33110621): need to understand token/session lifecycle\r\n    FirstPartyCredentialsProvider.prototype.setUserChangeListener = function (listener) {\r\n        // Fire with initial uid.\r\n        listener(User.FIRST_PARTY);\r\n    };\r\n    FirstPartyCredentialsProvider.prototype.removeUserChangeListener = function () { };\r\n    return FirstPartyCredentialsProvider;\r\n}());\r\nexport { FirstPartyCredentialsProvider };\r\n/**\r\n * Builds a CredentialsProvider depending on the type of\r\n * the credentials passed in.\r\n */\r\nexport function makeCredentialsProvider(credentials) {\r\n    if (!credentials) {\r\n        return new EmptyCredentialsProvider();\r\n    }\r\n    switch (credentials.type) {\r\n        case 'gapi':\r\n            return new FirstPartyCredentialsProvider(credentials.client, credentials.sessionIndex || '0');\r\n        case 'provider':\r\n            return credentials.client;\r\n        default:\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeCredentialsProvider failed due to invalid credential type');\r\n    }\r\n}\r\n//# sourceMappingURL=credentials.js.map\r\n",null]}