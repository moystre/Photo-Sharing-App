{"remainingRequest":"D:\\Documents\\VS Code Projects\\photo-sharing-app\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\Documents\\VS Code Projects\\photo-sharing-app\\node_modules\\@firebase\\firestore\\dist\\esm\\src\\local\\indexeddb_schema.js","dependencies":[{"path":"D:\\Documents\\VS Code Projects\\photo-sharing-app\\node_modules\\@firebase\\firestore\\dist\\esm\\src\\local\\indexeddb_schema.js","mtime":1519691373563},{"path":"D:\\Documents\\VS Code Projects\\photo-sharing-app\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1518892899207},{"path":"D:\\Documents\\VS Code Projects\\photo-sharing-app\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518892910875}],"contextDependencies":[],"result":["/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { assert } from '../util/assert';\r\nimport { encode } from './encoded_resource_path';\r\nexport var SCHEMA_VERSION = 1;\r\n/** Performs database creation and (in the future) upgrades between versions. */\r\nexport function createOrUpgradeDb(db, oldVersion) {\r\n    assert(oldVersion === 0, 'Unexpected upgrade from version ' + oldVersion);\r\n    db.createObjectStore(DbMutationQueue.store, {\r\n        keyPath: DbMutationQueue.keyPath\r\n    });\r\n    // TODO(mikelehen): Get rid of \"as any\" if/when TypeScript fixes their\r\n    // types. https://github.com/Microsoft/TypeScript/issues/14322\r\n    db.createObjectStore(DbMutationBatch.store, \r\n    // tslint:disable-next-line:no-any\r\n    { keyPath: DbMutationBatch.keyPath });\r\n    var targetDocumentsStore = db.createObjectStore(DbTargetDocument.store, \r\n    // tslint:disable-next-line:no-any\r\n    { keyPath: DbTargetDocument.keyPath });\r\n    targetDocumentsStore.createIndex(DbTargetDocument.documentTargetsIndex, DbTargetDocument.documentTargetsKeyPath, { unique: true });\r\n    var targetStore = db.createObjectStore(DbTarget.store, {\r\n        keyPath: DbTarget.keyPath\r\n    });\r\n    // NOTE: This is unique only because the TargetId is the suffix.\r\n    targetStore.createIndex(DbTarget.queryTargetsIndexName, DbTarget.queryTargetsKeyPath, { unique: true });\r\n    // NOTE: keys for these stores are specified explicitly rather than using a\r\n    // keyPath.\r\n    db.createObjectStore(DbDocumentMutation.store);\r\n    db.createObjectStore(DbRemoteDocument.store);\r\n    db.createObjectStore(DbOwner.store);\r\n    db.createObjectStore(DbTargetGlobal.store);\r\n}\r\n/**\r\n * Wrapper class to store timestamps (seconds and nanos) in IndexedDb objects.\r\n */\r\nvar DbTimestamp = /*@__PURE__*/ (function () {\r\n    function DbTimestamp(seconds, nanos) {\r\n        this.seconds = seconds;\r\n        this.nanos = nanos;\r\n    }\r\n    return DbTimestamp;\r\n}());\r\nexport { DbTimestamp };\r\n/**\r\n * A singleton object to be stored in the 'owner' store in IndexedDb.\r\n *\r\n * A given database can be owned by a single tab at a given time. That tab\r\n * must validate that it is still the owner before every write operation and\r\n * should regularly write an updated timestamp to prevent other tabs from\r\n * \"stealing\" ownership of the db.\r\n */\r\nvar DbOwner = /*@__PURE__*/ (function () {\r\n    function DbOwner(ownerId, leaseTimestampMs) {\r\n        this.ownerId = ownerId;\r\n        this.leaseTimestampMs = leaseTimestampMs;\r\n    }\r\n    /** Name of the IndexedDb object store. */\r\n    DbOwner.store = 'owner';\r\n    return DbOwner;\r\n}());\r\nexport { DbOwner };\r\n/**\r\n * An object to be stored in the 'mutationQueues' store in IndexedDb.\r\n *\r\n * Each user gets a single queue of MutationBatches to apply to the server.\r\n * DbMutationQueue tracks the metadata about the queue.\r\n */\r\nvar DbMutationQueue = /*@__PURE__*/ (function () {\r\n    function DbMutationQueue(\r\n        /**\r\n         * The normalized user ID to which this queue belongs.\r\n         */\r\n        userId, \r\n        /**\r\n         * An identifier for the highest numbered batch that has been acknowledged\r\n         * by the server. All MutationBatches in this queue with batchIds less\r\n         * than or equal to this value are considered to have been acknowledged by\r\n         * the server.\r\n         */\r\n        lastAcknowledgedBatchId, \r\n        /**\r\n         * A stream token that was previously sent by the server.\r\n         *\r\n         * See StreamingWriteRequest in datastore.proto for more details about\r\n         * usage.\r\n         *\r\n         * After sending this token, earlier tokens may not be used anymore so\r\n         * only a single stream token is retained.\r\n         */\r\n        lastStreamToken) {\r\n        this.userId = userId;\r\n        this.lastAcknowledgedBatchId = lastAcknowledgedBatchId;\r\n        this.lastStreamToken = lastStreamToken;\r\n    }\r\n    /** Name of the IndexedDb object store.  */\r\n    DbMutationQueue.store = 'mutationQueues';\r\n    /** Keys are automatically assigned via the userId property. */\r\n    DbMutationQueue.keyPath = 'userId';\r\n    return DbMutationQueue;\r\n}());\r\nexport { DbMutationQueue };\r\n/**\r\n * An object to be stored in the 'mutations' store in IndexedDb.\r\n *\r\n * Represents a batch of user-level mutations intended to be sent to the server\r\n * in a single write. Each user-level batch gets a separate DbMutationBatch\r\n * with a new batchId.\r\n */\r\nvar DbMutationBatch = /*@__PURE__*/ (function () {\r\n    function DbMutationBatch(\r\n        /**\r\n         * The normalized user ID to which this batch belongs.\r\n         */\r\n        userId, \r\n        /**\r\n         * An identifier for this batch, allocated by the mutation queue in a\r\n         * monotonically increasing manner.\r\n         */\r\n        batchId, \r\n        /**\r\n         * The local write time of the batch, stored as milliseconds since the\r\n         * epoch.\r\n         */\r\n        localWriteTimeMs, \r\n        /**\r\n         * A list of mutations to apply. All mutations will be applied atomically.\r\n         *\r\n         * Mutations are serialized via JsonProtoSerializer.toMutation().\r\n         */\r\n        mutations) {\r\n        this.userId = userId;\r\n        this.batchId = batchId;\r\n        this.localWriteTimeMs = localWriteTimeMs;\r\n        this.mutations = mutations;\r\n    }\r\n    /** Name of the IndexedDb object store.  */\r\n    DbMutationBatch.store = 'mutations';\r\n    /** Keys are automatically assigned via the userId, batchId properties. */\r\n    DbMutationBatch.keyPath = ['userId', 'batchId'];\r\n    return DbMutationBatch;\r\n}());\r\nexport { DbMutationBatch };\r\n/**\r\n * An object to be stored in the 'documentMutations' store in IndexedDb.\r\n *\r\n * A manually maintained index of all the mutation batches that affect a given\r\n * document key. The rows in this table are references based on the contents of\r\n * DbMutationBatch.mutations.\r\n */\r\nvar DbDocumentMutation = /*@__PURE__*/ (function () {\r\n    function DbDocumentMutation() {\r\n    }\r\n    /**\r\n     * Creates a [userId] key for use in the DbDocumentMutations index to iterate\r\n     * over all of a user's document mutations.\r\n     */\r\n    DbDocumentMutation.prefixForUser = function (userId) {\r\n        return [userId];\r\n    };\r\n    /**\r\n     * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\r\n     * index to iterate over all at document mutations for a given path or lower.\r\n     */\r\n    DbDocumentMutation.prefixForPath = function (userId, path) {\r\n        return [userId, encode(path)];\r\n    };\r\n    /**\r\n     * Creates a full index key of [userId, encodedPath, batchId] for inserting\r\n     * and deleting into the DbDocumentMutations index.\r\n     */\r\n    DbDocumentMutation.key = function (userId, path, batchId) {\r\n        return [userId, encode(path), batchId];\r\n    };\r\n    DbDocumentMutation.store = 'documentMutations';\r\n    /**\r\n     * Because we store all the useful information for this store in the key,\r\n     * there is no useful information to store as the value. The raw (unencoded)\r\n     * path cannot be stored because IndexedDb doesn't store prototype\r\n     * information.\r\n     */\r\n    DbDocumentMutation.PLACEHOLDER = new DbDocumentMutation();\r\n    return DbDocumentMutation;\r\n}());\r\nexport { DbDocumentMutation };\r\n/**\r\n * Represents the known absence of a document at a particular version.\r\n * Stored in IndexedDb as part of a DbRemoteDocument object.\r\n */\r\nvar DbNoDocument = /*@__PURE__*/ (function () {\r\n    function DbNoDocument(path, readTime) {\r\n        this.path = path;\r\n        this.readTime = readTime;\r\n    }\r\n    return DbNoDocument;\r\n}());\r\nexport { DbNoDocument };\r\n/**\r\n * An object to be stored in the 'remoteDocuments' store in IndexedDb. It\r\n * represents either a cached document (if it exists) or a cached \"no-document\"\r\n * (if it is known to not exist).\r\n *\r\n * Note: This is the persisted equivalent of a MaybeDocument and could perhaps\r\n * be made more general if necessary.\r\n */\r\nvar DbRemoteDocument = /*@__PURE__*/ (function () {\r\n    function DbRemoteDocument(\r\n        /**\r\n         * Set to an instance of a DbNoDocument if it is known that no document\r\n         * exists.\r\n         */\r\n        noDocument, \r\n        /**\r\n         * Set to an instance of a Document if there's a cached version of the\r\n         * document.\r\n         */\r\n        document) {\r\n        this.noDocument = noDocument;\r\n        this.document = document;\r\n    }\r\n    DbRemoteDocument.store = 'remoteDocuments';\r\n    return DbRemoteDocument;\r\n}());\r\nexport { DbRemoteDocument };\r\n/**\r\n * An object to be stored in the 'targets' store in IndexedDb.\r\n *\r\n * This is based on and should be kept in sync with the proto used in the iOS\r\n * client.\r\n *\r\n * Each query the client listens to against the server is tracked on disk so\r\n * that the query can be efficiently resumed on restart.\r\n */\r\nvar DbTarget = /*@__PURE__*/ (function () {\r\n    function DbTarget(\r\n        /**\r\n         * An auto-generated sequential numeric identifier for the query.\r\n         *\r\n         * Queries are stored using their canonicalId as the key, but these\r\n         * canonicalIds can be quite long so we additionally assign a unique\r\n         * queryId which can be used by referenced data structures (e.g.\r\n         * indexes) to minimize the on-disk cost.\r\n         */\r\n        targetId, \r\n        /**\r\n         * The canonical string representing this query. This is not unique.\r\n         */\r\n        canonicalId, \r\n        /**\r\n         * The last readTime received from the Watch Service for this query.\r\n         *\r\n         * This is the same value as TargetChange.read_time in the protos.\r\n         */\r\n        readTime, \r\n        /**\r\n         * An opaque, server-assigned token that allows watching a query to be\r\n         * resumed after disconnecting without retransmitting all the data\r\n         * that matches the query. The resume token essentially identifies a\r\n         * point in time from which the server should resume sending results.\r\n         *\r\n         * This is related to the snapshotVersion in that the resumeToken\r\n         * effectively also encodes that value, but the resumeToken is opaque\r\n         * and sometimes encodes additional information.\r\n         *\r\n         * A consequence of this is that the resumeToken should be used when\r\n         * asking the server to reason about where this client is in the watch\r\n         * stream, but the client should use the snapshotVersion for its own\r\n         * purposes.\r\n         *\r\n         * This is the same value as TargetChange.resume_token in the protos.\r\n         */\r\n        resumeToken, \r\n        /**\r\n         * A sequence number representing the last time this query was\r\n         * listened to, used for garbage collection purposes.\r\n         *\r\n         * Conventionally this would be a timestamp value, but device-local\r\n         * clocks are unreliable and they must be able to create new listens\r\n         * even while disconnected. Instead this should be a monotonically\r\n         * increasing number that's incremented on each listen call.\r\n         *\r\n         * This is different from the queryId since the queryId is an\r\n         * immutable identifier assigned to the Query on first use while\r\n         * lastListenSequenceNumber is updated every time the query is\r\n         * listened to.\r\n         */\r\n        lastListenSequenceNumber, \r\n        /**\r\n         * The query for this target.\r\n         *\r\n         * Because canonical ids are not unique we must store the actual query. We\r\n         * use the proto to have an object we can persist without having to\r\n         * duplicate translation logic to and from a `Query` object.\r\n         */\r\n        query) {\r\n        this.targetId = targetId;\r\n        this.canonicalId = canonicalId;\r\n        this.readTime = readTime;\r\n        this.resumeToken = resumeToken;\r\n        this.lastListenSequenceNumber = lastListenSequenceNumber;\r\n        this.query = query;\r\n    }\r\n    DbTarget.store = 'targets';\r\n    /** Keys are automatically assigned via the targetId property. */\r\n    DbTarget.keyPath = 'targetId';\r\n    /** The name of the queryTargets index. */\r\n    DbTarget.queryTargetsIndexName = 'queryTargetsIndex';\r\n    /**\r\n     * The index of all canonicalIds to the targets that they match. This is not\r\n     * a unique mapping because canonicalId does not promise a unique name for all\r\n     * possible queries, so we append the targetId to make the mapping unique.\r\n     */\r\n    DbTarget.queryTargetsKeyPath = ['canonicalId', 'targetId'];\r\n    return DbTarget;\r\n}());\r\nexport { DbTarget };\r\n/**\r\n * An object representing an association between a target and a document.\r\n * Stored in the targetDocument object store to store the documents tracked by a\r\n * particular target.\r\n */\r\nvar DbTargetDocument = /*@__PURE__*/ (function () {\r\n    function DbTargetDocument(\r\n        /**\r\n         * The targetId identifying a target.\r\n         */\r\n        targetId, \r\n        /**\r\n         * The path to the document, as encoded in the key.\r\n         */\r\n        path) {\r\n        this.targetId = targetId;\r\n        this.path = path;\r\n    }\r\n    /** Name of the IndexedDb object store.  */\r\n    DbTargetDocument.store = 'targetDocuments';\r\n    /** Keys are automatically assigned via the targetId, path properties. */\r\n    DbTargetDocument.keyPath = ['targetId', 'path'];\r\n    /** The index name for the reverse index. */\r\n    DbTargetDocument.documentTargetsIndex = 'documentTargetsIndex';\r\n    /** We also need to create the reverse index for these properties. */\r\n    DbTargetDocument.documentTargetsKeyPath = ['path', 'targetId'];\r\n    return DbTargetDocument;\r\n}());\r\nexport { DbTargetDocument };\r\n/**\r\n * A record of global state tracked across all Targets, tracked separately\r\n * to avoid the need for extra indexes.\r\n *\r\n * This should be kept in-sync with the proto used in the iOS client.\r\n */\r\nvar DbTargetGlobal = /*@__PURE__*/ (function () {\r\n    function DbTargetGlobal(\r\n        /**\r\n         * The highest numbered target id across all targets.\r\n         *\r\n         * See DbTarget.targetId.\r\n         */\r\n        highestTargetId, \r\n        /**\r\n         * The highest numbered lastListenSequenceNumber across all targets.\r\n         *\r\n         * See DbTarget.lastListenSequenceNumber.\r\n         */\r\n        highestListenSequenceNumber, \r\n        /**\r\n         * A global snapshot version representing the last consistent snapshot we\r\n         * received from the backend. This is monotonically increasing and any\r\n         * snapshots received from the backend prior to this version (e.g. for\r\n         * targets resumed with a resumeToken) should be suppressed (buffered)\r\n         * until the backend has caught up to this snapshot version again. This\r\n         * prevents our cache from ever going backwards in time.\r\n         */\r\n        lastRemoteSnapshotVersion) {\r\n        this.highestTargetId = highestTargetId;\r\n        this.highestListenSequenceNumber = highestListenSequenceNumber;\r\n        this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;\r\n    }\r\n    /**\r\n     * The key string used for the single object that exists in the\r\n     * DbTargetGlobal store.\r\n     */\r\n    DbTargetGlobal.key = 'targetGlobalKey';\r\n    DbTargetGlobal.store = 'targetGlobal';\r\n    return DbTargetGlobal;\r\n}());\r\nexport { DbTargetGlobal };\r\n/**\r\n * The list of all IndexedDB stored used by the SDK. This is used when creating\r\n * transactions so that access across all stores is done atomically.\r\n */\r\nexport var ALL_STORES = [\r\n    DbMutationQueue.store,\r\n    DbMutationBatch.store,\r\n    DbDocumentMutation.store,\r\n    DbRemoteDocument.store,\r\n    DbTarget.store,\r\n    DbOwner.store,\r\n    DbTargetGlobal.store,\r\n    DbTargetDocument.store\r\n];\r\n//# sourceMappingURL=indexeddb_schema.js.map\r\n",null]}